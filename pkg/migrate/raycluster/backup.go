package raycluster

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/lburgazzoli/odh-cli/pkg/util/client"
	"github.com/lburgazzoli/odh-cli/pkg/util/iostreams"
	"sigs.k8s.io/yaml"
)

// PreUpgrade runs pre-upgrade: preflight checks and backup of RayClusters to outputDir (rhoai-2.x and rhoai-3.x subdirs).
// If outputDir is empty, returns error (caller should prompt or use default).
func PreUpgrade(
	ctx context.Context,
	c client.Client,
	outputDir string,
	clusterName string,
	namespace string,
	checks []PreflightCheck,
	io iostreams.Interface,
) (savedFiles []string, err error) {
	if outputDir == "" {
		return nil, fmt.Errorf("output directory is required")
	}

	io.Errorf("Running pre-upgrade checks...")
	io.Errorf("------------------------------------------------------------")

	// Report preflight
	for _, chk := range checks {
		status := "[OK]"
		if !chk.Passed {
			status = "[FAIL]"
		}
		io.Errorf("  %s %s: %s", status, chk.Name, chk.Message)
		if len(chk.Details) > 0 && !chk.Passed {
			for _, d := range chk.Details {
				io.Errorf("       - %s", d)
			}
		}
		if !chk.Passed && chk.Required && chk.Help != "" {
			io.Errorf("       %s", chk.Help)
		}
	}

	io.Errorf("------------------------------------------------------------")

	allPassed := true
	hasRequiredFailure := false
	for _, chk := range checks {
		if !chk.Passed {
			allPassed = false
			if chk.Required {
				hasRequiredFailure = true
			}
		}
	}
	if hasRequiredFailure {
		io.Errorf("")
		io.Errorf("Pre-upgrade checks failed. Please resolve the issues above before proceeding with the RHOAI upgrade.")
		return nil, fmt.Errorf("pre-upgrade checks failed")
	}
	if allPassed {
		io.Errorf("All pre-upgrade checks passed.")
	} else {
		io.Errorf("Pre-upgrade checks completed with warnings.")
	}
	io.Errorf("")

	outputDirExisted := true
	if _, err := os.Stat(outputDir); os.IsNotExist(err) {
		outputDirExisted = false
	}
	if err := os.MkdirAll(outputDir, 0o750); err != nil {
		return nil, fmt.Errorf("create backup directory: %w", err)
	}
	if !outputDirExisted {
		io.Errorf("Created backup directory: %s", outputDir)
	}

	rhoai2Dir := filepath.Join(outputDir, BackupSubdirRHOAI2x)
	rhoai3Dir := filepath.Join(outputDir, BackupSubdirRHOAI3x)
	for _, d := range []string{rhoai2Dir, rhoai3Dir} {
		if err := os.MkdirAll(d, 0o750); err != nil {
			return nil, fmt.Errorf("create backup subdirectory %s: %w", d, err)
		}
	}

	clusters, err := GetClusters(ctx, c, clusterName, namespace)
	if err != nil {
		return nil, err
	}
	if len(clusters) == 0 {
		io.Errorf("No RayClusters found to backup")
		return nil, nil
	}

	scopeMsg := "all clusters across all namespaces"
	if clusterName != "" && namespace != "" {
		scopeMsg = fmt.Sprintf("cluster '%s' in namespace '%s'", clusterName, namespace)
	} else if namespace != "" {
		scopeMsg = fmt.Sprintf("all clusters in namespace '%s'", namespace)
	}
	io.Errorf("Backing up %d RayCluster(s) (%s)", len(clusters), scopeMsg)
	io.Errorf("")

	for _, rc := range clusters {
		name := rc.GetName()
		ns := rc.GetNamespace()
		if ns == "" {
			ns = "default"
		}

		obj2x := rc.DeepCopy()
		RemoveAutogeneratedFields(obj2x.Object)
		f2x := filepath.Join(rhoai2Dir, "raycluster-"+name+"-"+ns+".yaml")
		if err := writeUnstructuredToFile(obj2x, f2x); err != nil {
			io.Errorf("  Error backing up %s (RHOAI 2.x): %v", name, err)
		}

		obj3x := rc.DeepCopy()
		RemoveAutogeneratedFields(obj3x.Object)
		ProcessRayClusterYAML(obj3x)
		f3x := filepath.Join(rhoai3Dir, "raycluster-"+name+"-"+ns+".yaml")
		if err := writeUnstructuredToFile(obj3x, f3x); err != nil {
			io.Errorf("  Error backing up %s (RHOAI 3.x): %v", name, err)
		} else {
			savedFiles = append(savedFiles, f3x)
			io.Errorf("  Backed up: %s (namespace: %s)", name, ns)
		}
	}

	return savedFiles, nil
}

func writeUnstructuredToFile(u *unstructured.Unstructured, path string) error {
	data, err := yaml.Marshal(u.Object)
	if err != nil {
		return err
	}

	return os.WriteFile(path, data, 0o600)
}
