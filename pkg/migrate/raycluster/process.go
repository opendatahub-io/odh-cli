package raycluster

import (
	"fmt"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// RemoveAutogeneratedFields recursively removes Kubernetes autogenerated fields from obj (in-place).
func RemoveAutogeneratedFields(obj map[string]any) {
	for k := range obj {
		if _, ok := AutogeneratedFields[k]; ok {
			delete(obj, k)
			continue
		}
		switch v := obj[k].(type) {
		case map[string]any:
			RemoveAutogeneratedFields(v)
		case []any:
			for _, item := range v {
				if m, ok := item.(map[string]any); ok {
					RemoveAutogeneratedFields(m)
				}
			}
		}
	}
}

// RemoveKueueWorkloadAnnotations removes Kueue workload/podset annotations from the
// RayCluster so that backup/restore does not conflict with Kueue admission (which
// assigns new workload names when the cluster is created).
func RemoveKueueWorkloadAnnotations(rc *unstructured.Unstructured) {
	stripFromMap := func(ann map[string]any) {
		if ann == nil {
			return
		}
		for k := range KueueAnnotationsToStrip {
			delete(ann, k)
		}
	}
	// Cluster-level metadata.annotations
	if ann, ok, _ := unstructured.NestedMap(rc.Object, "metadata", "annotations"); ok {
		stripFromMap(ann)
		_ = unstructured.SetNestedMap(rc.Object, ann, "metadata", "annotations")
	}
	spec, ok, _ := unstructured.NestedMap(rc.Object, "spec")
	if !ok {
		return
	}
	// spec.headGroupSpec.template.metadata.annotations
	if head, ok, _ := unstructured.NestedMap(spec, "headGroupSpec"); ok {
		if meta, ok, _ := unstructured.NestedMap(head, "template", "metadata"); ok {
			if ann, ok, _ := unstructured.NestedMap(meta, "annotations"); ok {
				stripFromMap(ann)
				_ = unstructured.SetNestedMap(meta, ann, "annotations")
				_ = unstructured.SetNestedMap(head, meta, "template", "metadata")
				_ = unstructured.SetNestedMap(spec, head, "headGroupSpec")
			}
		}
	}
	// spec.workerGroupSpecs[].template.metadata.annotations
	workers, ok, _ := unstructured.NestedSlice(spec, "workerGroupSpecs")
	if !ok {
		_ = unstructured.SetNestedField(rc.Object, spec, "spec")
		return
	}
	for i, w := range workers {
		wm, _ := w.(map[string]any)
		if meta, ok, _ := unstructured.NestedMap(wm, "template", "metadata"); ok {
			if ann, ok, _ := unstructured.NestedMap(meta, "annotations"); ok {
				stripFromMap(ann)
				_ = unstructured.SetNestedMap(meta, ann, "annotations")
				_ = unstructured.SetNestedMap(wm, meta, "template", "metadata")
				workers[i] = wm
			}
		}
	}
	_ = unstructured.SetNestedSlice(spec, workers, "workerGroupSpecs")
	_ = unstructured.SetNestedField(rc.Object, spec, "spec")
}

// HasTLSOAuthComponents returns true if the RayCluster has TLS/OAuth components that need migration,
// plus a short list of component descriptions.
func HasTLSOAuthComponents(rc *unstructured.Unstructured) (bool, []string) {
	var components []string
	spec, ok, _ := unstructured.NestedMap(rc.Object, "spec")
	if !ok {
		return false, nil
	}

	checkPodSpec := func(podSpec map[string]any, group string) {
		if containers, ok, _ := unstructured.NestedSlice(podSpec, "containers"); ok {
			for _, c := range containers {
				cm, _ := c.(map[string]any)
				name, _, _ := unstructured.NestedString(cm, "name")
				if _, remove := ContainersToRemove[name]; remove {
					components = append(components, group+": oauth-proxy sidecar container")
				}
				if envs, ok, _ := unstructured.NestedSlice(cm, "env"); ok {
					for _, e := range envs {
						em, _ := e.(map[string]any)
						envName, _, _ := unstructured.NestedString(em, "name")
						if _, has := TLSEnvVars[envName]; has {
							components = append(components, group+": TLS env var "+envName)
							break
						}
					}
				}
			}
		}
		if inits, ok, _ := unstructured.NestedSlice(podSpec, "initContainers"); ok {
			for _, c := range inits {
				cm, _ := c.(map[string]any)
				name, _, _ := unstructured.NestedString(cm, "name")
				if _, remove := CodeFlareInitContainers[name]; remove {
					components = append(components, group+": initContainer '"+name+"' (cert generation)")
				}
			}
		}
		if vols, ok, _ := unstructured.NestedSlice(podSpec, "volumes"); ok {
			for _, v := range vols {
				vm, _ := v.(map[string]any)
				name, _, _ := unstructured.NestedString(vm, "name")
				if _, has := VolumesToRemove[name]; has {
					components = append(components, group+": TLS volume "+name)
				}
			}
		}
	}

	if head, ok, _ := unstructured.NestedMap(spec, "headGroupSpec"); ok {
		if enableIngress, _, _ := unstructured.NestedBool(head, "enableIngress"); enableIngress {
			components = append(components, "head: enableIngress=true")
		}
		if template, ok, _ := unstructured.NestedMap(head, "template", "spec"); ok {
			checkPodSpec(template, "head")
		}
	}
	if workers, ok, _ := unstructured.NestedSlice(spec, "workerGroupSpecs"); ok {
		for i, w := range workers {
			wm, _ := w.(map[string]any)
			if template, ok, _ := unstructured.NestedMap(wm, "template", "spec"); ok {
				checkPodSpec(template, "worker["+fmt.Sprint(i)+"]")
			}
		}
	}

	return len(components) > 0, components
}

// ProcessRayClusterYAML removes TLS/OAuth-related components from the RayCluster object (in-place).
func ProcessRayClusterYAML(rc *unstructured.Unstructured) {
	spec, ok, _ := unstructured.NestedMap(rc.Object, "spec")
	if !ok {
		return
	}

	processContainer := func(container map[string]any) {
		if envs, ok, _ := unstructured.NestedSlice(container, "env"); ok {
			var kept []any
			for _, e := range envs {
				em, _ := e.(map[string]any)
				name, _, _ := unstructured.NestedString(em, "name")
				if _, remove := TLSEnvVars[name]; !remove {
					kept = append(kept, e)
				}
			}
			if len(kept) == 0 {
				unstructured.RemoveNestedField(container, "env")
			} else {
				_ = unstructured.SetNestedSlice(container, kept, "env")
			}
		}
		if mounts, ok, _ := unstructured.NestedSlice(container, "volumeMounts"); ok {
			var kept []any
			for _, m := range mounts {
				mm, _ := m.(map[string]any)
				name, _, _ := unstructured.NestedString(mm, "name")
				if _, remove := VolumeMountsToRemove[name]; !remove {
					kept = append(kept, m)
				}
			}
			if len(kept) == 0 {
				unstructured.RemoveNestedField(container, "volumeMounts")
			} else {
				_ = unstructured.SetNestedSlice(container, kept, "volumeMounts")
			}
		}
	}

	processPodSpec := func(podSpec map[string]any) {
		if containers, ok, _ := unstructured.NestedSlice(podSpec, "containers"); ok {
			var kept []any
			for _, c := range containers {
				cm, _ := c.(map[string]any)
				name, _, _ := unstructured.NestedString(cm, "name")
				if _, remove := ContainersToRemove[name]; !remove {
					processContainer(cm)
					kept = append(kept, c)
				}
			}
			_ = unstructured.SetNestedSlice(podSpec, kept, "containers")
		}
		if inits, ok, _ := unstructured.NestedSlice(podSpec, "initContainers"); ok {
			var kept []any
			for _, c := range inits {
				cm, _ := c.(map[string]any)
				name, _, _ := unstructured.NestedString(cm, "name")
				if _, remove := CodeFlareInitContainers[name]; !remove {
					kept = append(kept, c)
				}
			}
			if len(kept) == 0 {
				unstructured.RemoveNestedField(podSpec, "initContainers")
			} else {
				_ = unstructured.SetNestedSlice(podSpec, kept, "initContainers")
			}
		}
		unstructured.RemoveNestedField(podSpec, "serviceAccountName")
		if vols, ok, _ := unstructured.NestedSlice(podSpec, "volumes"); ok {
			var kept []any
			for _, v := range vols {
				vm, _ := v.(map[string]any)
				name, _, _ := unstructured.NestedString(vm, "name")
				if _, remove := VolumesToRemove[name]; !remove {
					kept = append(kept, v)
				}
			}
			_ = unstructured.SetNestedSlice(podSpec, kept, "volumes")
		}
	}

	if head, ok, _ := unstructured.NestedMap(spec, "headGroupSpec"); ok {
		if enableIngress, _, _ := unstructured.NestedBool(head, "enableIngress"); enableIngress {
			_ = unstructured.SetNestedField(head, false, "enableIngress")
		}
		if template, ok, _ := unstructured.NestedMap(head, "template", "spec"); ok {
			processPodSpec(template)
			_ = unstructured.SetNestedField(head, template, "template", "spec")
		}
		_ = unstructured.SetNestedField(spec, head, "headGroupSpec")
	}
	if workers, ok, _ := unstructured.NestedSlice(spec, "workerGroupSpecs"); ok {
		for i, w := range workers {
			wm, _ := w.(map[string]any)
			if template, ok, _ := unstructured.NestedMap(wm, "template", "spec"); ok {
				processPodSpec(template)
				_ = unstructured.SetNestedField(wm, template, "template", "spec")
			}
			workers[i] = wm
		}
		_ = unstructured.SetNestedSlice(spec, workers, "workerGroupSpecs")
	}
	_ = unstructured.SetNestedField(rc.Object, spec, "spec")
}

// IsClusterMigrated returns true if the RayCluster is already migrated, plus a short reason string.
func IsClusterMigrated(rc *unstructured.Unstructured) (bool, string) {
	ann := rc.GetAnnotations()
	hasAnnotation := ann[SecureNetworkAnnotation] == "true"
	hasTLS, components := HasTLSOAuthComponents(rc)

	if hasAnnotation && !hasTLS {
		return true, "Already migrated (has annotation, no TLS/OAuth components)"
	}
	if hasAnnotation && hasTLS {
		desc := "Partially migrated (has annotation but still has components)"
		if len(components) > 0 {
			desc = "Partially migrated (has annotation but still has: " + components[0]
			for i := 1; i < len(components) && i < 3; i++ {
				desc += ", " + components[i]
			}
			desc += ")"
		}
		return false, desc
	}
	if !hasAnnotation && !hasTLS {
		return false, "Needs annotation only (no TLS/OAuth components found)"
	}
	desc := "Needs migration (has TLS/OAuth components)"
	if len(components) > 0 {
		desc = "Needs migration (has: " + components[0]
		for i := 1; i < len(components) && i < 3; i++ {
			desc += ", " + components[i]
		}
		desc += ")"
	}
	return false, desc
}
